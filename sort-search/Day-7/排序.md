##### 二、排序

###### 1.什么是排序？

   首先，必须比较两个值以查看哪个更小（或更大）。为了对集合进行排序，需要一些系统的方法来比较值，以查看是否有问题。衡量排序过程的效率：比较的总数（尽可能减少比对的次数）。当值处于不正确的位置的时候，需要交换它们。交换操作比较浪费时间和内存，所以评价一个排序算法的效率的时候：比较的总数和交换的总数



###### 2.冒泡排序

   [54,26,93,17,77,31,44,55,20]

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

3. 针对所有的元素重复以上的步骤，除了最后一个。

4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

   ***\*短冒泡排序算法\****  当列表遍历过程中没有交换，则证明列表已经排序，此时可以修改冒泡排序提前停止



###### 3.选择排序

改进了冒泡排序，每次遍历列表只做一次交换。

   选择排序会在遍历的时候寻找最大的值，并且在遍历完后，将其放到正确的位置。

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

3. 重复第二步，直到所有元素均排序完毕。

   [54,26,93,17,77,31,44,55,20]

   第1次  [54,26,20，17,77,31,44,55，93]

   第2次  [54,26,20，17,55,31,44，77，93]

   第3次  [54,26,20，17,44,31,55，77，93]

   第4次  [31,26,20，17,44,54，55，77，93]

   第5次  [31,26,20，17,44,54，55，77，93]

   第6次  [17,26,20，31,44,54，55，77，93]

   第7次 [17,20，26，31,44,54，55，77，93]



###### 4.插入排序

1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

​      [54,26,93,17,77,31,44,55,20]

​      第1次   有序[54]      未排序序列[26,93,17,77,31,44,55,20]

​      第2次：[26,54]     [93,17,77,31,44,55,20]

​      第3次：[26,54,93]     [17,77,31,44,55,20]

​      第4次：[17,26,54,93]     [77,31,44,55,20]

​      第5次：[17,26,54,77,93]     [31,44,55,20]

​      第6次：[17,26,31,54,77,93]     [44,55,20]

​      第7次：[17,26,31,44,54,77,93]     [55,20]

​      第8次：[17,26,31,44,54,55,77,93]     [20]

​      第9次：[17,20,26,31,44,54,55,77,93]     []



###### 5.希尔排序

1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

2. 按增量序列个数 k，对序列进行 k 趟排序；

3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

​         [54,26,93,17,77,31,44,55,20]

​        增量序列个数为3，9/3 = 3

​      第1个子序列：[54,17,44]        [17,44,54] 

​        第2个子序列：[26,77,55]        [26,55,77]

​        第3个子序列：[93,31,20]        [20,31,93]

​        第1个子序列排序后：[17,26,93,44,77,31,54,55,20]

​        第2个子序列排序后：[17,26,93,44,55,31,54,77,20]

​        第3个子序列排序后：[17,26,20,44,55,31,54,77,93]

​       从n/2子列表开始，下一次n/4,最终，单个列表按照基本插入排序进行排序，移位约等于1/3交换，O(nlog^2n) = O(n^3/2)



###### 6.归并排序

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；

2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；

3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；

4. 重复步骤 3 直到某一指针达到序列尾；

5. 将另一序列剩下的所有元素直接复制到合并序列尾。 

​    归并排序是一种递归算法，不断将列表拆分为一半。直到列表为空或只有一个元素。 合并分割

   [54,26,93,17,77,31,44,55,20]

​     ***\*分割\****

​     第1次分割   [54,26,93,17]                        [77,31,44,55,20]

​     第2次分割   [54,26]   [93,17]                   [77,31]   [44,55,20]

​     第3次分割   [54]  [26]  [93]  [17]            [77] [31]      [44]  [55,20]

​     第4次分割   [54]  [26]  [93]  [17]            [77] [31]      [44]  [55]  [20]

​     ***\*合并\****

​     第1次合并：[26,54]  [17,93]                  [31,77]    [20,44,55]

   第2次合并：[17,26,54,93]                  [20,31,44,55,77]

   第3次合并：[17,20,26,31,44,45,54,77,93]    



###### 7.快速排序

   从数列中挑出一个元素，称为 “基准”（pivot）;

   重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

   递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

   [54,26,93,17,77,31,44,55,20]

   假如选取数列第一个值为’基准‘

   [31,26,20,17,44]    54     [77,55,93]





##### 三、总结

1. 对于有序或者无序列表，顺序搜索的时间复杂度是：O(n)

2. 在最坏的情况下，有序列表的二分查找时间复杂度是：O(logn)

3. 哈希表可以提供恒定时间搜索

4. 冒泡排序，选择排序和插入排序，时间复杂度O(n^2)

5. 希尔排序通过排序增量子列表来改进插入排序，它落在O(n)和O(n^2)之间

6. 归并排序 O(nlogn),但是合并过程需要增加额外的空间

7. 快速排序O(nlogn),但如果分割点不在列表中间附近，可能会降到O(n^2)，它不需要额外空间

   

   

​     